import re
import unittest
import pandas as pd
import numpy as np
from fext_common import *

EXTRACTOR_NAME = 'ext-mem-rw-dump'

class TestChunkCreation(unittest.TestCase):
    sample_file = """#
# Memory Access Trace Generated By Pin
#
0x00007ffd37cd1493: W 0x000000361957ec40  1                0x1
0x00007ffd37cd1497: R 0x0000003619691060  8       0x3619690000
0x00007ffd37cd14a0: R 0x0000003619690090  8                  0
0x00007ffd37cd14ac: R 0x000000007ffe0384  1                  0
0x00007ffd37cd14b5: R 0x000000361957ec40  1                0x1
0x00007ffd37cd14bf: R 0x000000361957ec80  8      0x190c9617040
0x00007ffd37cd14c8: R 0x000000361957ec50  8                  0
0x00007ffd38cd14c8: R 0x000000361957ec50  8                  0
0x00007ffd37cd1493: W 0x000000361957ec40  1                0x1
"""
    def test_correct_number_of_chunks(self):
        test_data = pp_pin_output(self.sample_file.split('\n'))
        df = get_df_from_file(test_data)
        
        self.assertEqual(len(df), 9)

        chunk_mem_ref_deltas = get_chunk_mem_deltas(df)
        print chunk_mem_ref_deltas

        self.assertEqual(len(chunk_mem_ref_deltas), 1)
        self.assertEqual(chunk_mem_ref_deltas[0], 230203830252)


def parse_line(str):
    regex = r'(\w+): (W|R) (\w+) +(\d) +(\w+)'
    match = re.match(regex, str)

    if match:
        ins_addr = match.group(1)
        rw = match.group(2)
        tgt_addr = match.group(3)
        return int(ins_addr, 16), rw, int(tgt_addr, 16)
    else:
        return None


def get_df(stats):
    idx = [s[0] for s in stats]
    mem_access = {
        'RW': pd.Series([s[1] for s in stats], index=idx),
        'TGT': pd.Series([s[2] for s in stats], index=idx)
    }

    df = pd.DataFrame(mem_access)
    return df


def get_df_from_file(lines):
    stats = []
    for line in lines:
        p = parse_line(line)
        if p is not None:
            stats.append(p)

    return get_df(stats)


def get_idx_val(row):
    return row.index.values[0]

# TODO: Should create lots of different versions of this to test accuracy...
def get_chunks(df, chunk_size_bytes=10000):
   
    if len(df) < chunk_size_bytes:
        return [df]
    
    n_chunks = len(df) / chunk_size_bytes
    print 'n_chunks: ' + str(n_chunks)

    ret = []
    for i in range(0, n_chunks+1):
        start_idx = (i*chunk_size_bytes)
        chunk_df = df.iloc[start_idx:start_idx+chunk_size_bytes]
        if not chunk_df.empty:
            #print 'Chunk %d:%d len = %d' % (start_idx, start_idx + chunk_size_bytes, len(chunk_df))
            ret.append(chunk_df)

    return ret


def get_chunk_mem_deltas(df, mode='default'):
    ret = []
    for c in get_chunks(df):
        ret.append(calc_mem_access_delta(c, mode))

    return ret


# TODO: Add support for: sum, max, min, abs... of references from base reference
def calc_mem_access_delta(df, mode='default'):

    if len(df) == 1:
        return 0

    base_reference = df.head(1)['TGT'].values[0]

    tgt_deltas = df['TGT'].apply(lambda x: base_reference - x)
    return abs(tgt_deltas.sum())


if __name__ == '__main__':
    np.set_printoptions(suppress=True)

    df = get_df_from_file(get_pintool_output(EXTRACTOR_NAME))
    # Split mem access into chunks, and calculate the mem access delta (from first in chunk)
    chunk_tgt_deltas = get_chunk_mem_deltas(df)

    # Produce histogram
    # TODO: We will need to set static 'range' here so results are comparable accross all .exe's
    # TODO: Can we emit metadata (min,max), so we can see if range should expand as we process BAU?
    tdeltas = pd.DataFrame(chunk_tgt_deltas)
    count, division = np.histogram(tdeltas)

    print 'histogram buckets: %s' %(division)
    print 'histogram counts: %s' %(count)